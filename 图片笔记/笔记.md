# 组件库启航---

## 一、完成一个组件库需要考虑的问题

~~[react官网建议](https://react.docschina.org/docs/faq-structure.html)~~
    1. 文件结构和代码规范
       1. 和普通完成项目的写的主要呈现ui组件不一样，那类输出的大多是js css 和html页面。而我们组件库要做的是代码和一定的样式文件，主体中不需要任何展示的html
       2. 项目各层级目录结构和定义该项目的代码规范
          1. 文件结构官方文档建议的非常好[react官网建议](https://react.docschina.org/docs/faq-structure.html)
       1. 本节课所采取的目录结构很简单即src下components目录styles目录index.tsx同级即可。components目录下每个组件是一个文件夹如Button文件夹含button.tsx,button.test.tsx,style.scss三个文件即可。外层的styles是个全局样式目录
       2. 规范问题可以自己给项目配置Eslint即可如安装###eslint-config-react-app @typescript-eslint/eslint s###。但是由于我们代码是ts编写的，eslint虽然有，但是规则没有默认启用，我们需要手动添加一下vscode的配置文件不好直接在vscode的设置里更改settingjson
       文件，是独立的项目，可以在项目中建立.vscode/settings.json来配置(这些在create-react-app官方文档中写的)
    1. 需要考虑样式解决方案
       1. 项目比较复杂话，就需要良好的样式代码解决方案和一个结构的组织
    2. 组件需求分析和编码
       1. 组件种类繁多，本章讲解几种典型组件如何需求分析和编码
    3. 组件测试用例分析和编码
       1. 单元测试非常适用于组件，因为组件天生是逻辑独立的单元。单元测试的编写还能让我们的工作事半功倍
    4. 编写完后，还需要考虑代码打包输出和发布的过程
    5. 最后，CI/CD持续集成，文档生成等等

最后我们需要化繁为简，从简单入手，在需求中慢慢复杂。

## 二、开始创建组件库项目，给自己组件库起个名字吧（yan.ui）

## 三、样式系统初始化

### 3.1 样式解决方案分析

    -   Inline CSS
        直接使用 css 类名比 inlineCSS 在性能上好
    -   CSS in JS
        由于 css 天生不是一种可编程语言想实现编程效果，它和 inlinecss 挺像的，都不是把 css 代码写到独立的 css 文件中，而是把 css 抽象到 js 代码中，然后使用 js 的语言特性，可以对里面的属性进行各种操作这种 css in js 有 60 多种解决方案。最出名的是 styled component，但增加了成本和复杂度，css 的灵活度和层叠醒是 js 中编写达不到的，强行把两者混在一起是不好，尽量停止使用 css in js 行为
    -   sass/less 解决方案
        这种是公司和个人是最多的

### 3.2 样式系统文件结构

        ```javascript
            styles/
                _variables.scss(各种预设变量色彩字体等以及可配置设置(开关等))
                _mixins.scss(全局 mixins，复用逻辑的如添加shadow，transform等)
                _functions.scss(全局 functions)--用来计算逻辑返回新值的
            components/
                Button/
                    style.scss(组件单独的样式)
                    ...
        ```

### 3.3 创建自己组件库的色彩体系

#### 3.3.1 色彩常识

    -   系统色板:
        -   基础色板:参考 zhongguose 网站各种基础色，组件库都是需要些基础色作为可选项的
        -   中性色板：中性色板里含黑白灰这几种颜色。合理的选择中性色能够给页面信息具备良好的足色关系良好的阅读体验
    -   产品色板：说完系统色后，这个是和组件息息相关的产品组件色
        -   品牌色：如可口可乐的品牌色红和黑，品牌色是门面一般由主色和辅色两种组成的，组件库一种色组成也行。
        -   功能色板：代表成功色出错色失败色，一系列的功能状态色。功能色的选取需要符合用户的认知，建议在一套体系下功能色保持一致

#### 3.3.2 Bootstrap 的色彩体系

自行查阅

#### 3.3.3 开始操作 styles/\_variables.scss 文件

    -   react 脚手架默认不支持 sass 预编译处理，要先 npm 安装一下相关包
        npm install node-sass --save
    -   安装完后，就可以在全局预设变量的 scss 文件中统一组件库的色彩体系了
        文件中设定系统色板 功能色板了。
    -   在全局变量样式文件中做组件库样式变量分类
        -   基础色彩系统
        -   字体系统
        -   表单(输入框按钮边框)
        -   可配置开关
    -   把写好的样式加到样式系统中

#### 3.3.4 初次亮相添加 normalize.css 文件

    这是推特的一个工程师贡献的项目，是一个很小的css文件，它在默认html元素样式上提供了跨浏览器的一个高度一致性，被很多框架都使用。现在就在我们项目中根样式文件styles下添加这个normalize.css文件。我们还要将它改成scss格式---最后重命名为_reboot.scss

#### 3.3.5 最后添加样式入口文件 index.scss

    注意点：

    -   前两个文件都是以下划线开头的，这在 scss 中称之为 partials，这是告诉 scss 不要将其编译到 css 文件中去，但是在我们导入这些文件的时候不需要添加下划线。这些 partial 过的文件只能当作模块导入不能单独编译成 css 文件

## 四、开始编写组件--Button 组件开始

### 4.1 button 组件需求分析

#### 4.1.1 原型图层面--原型图分析

    -   不同的 Button Type：Primary 类型+Default 类型+Danger 类型+LinkButton 类型(可控制不同 class 名字)
    -   不同的 Button Size：Normal+Small+Large(可控制 class 名字)
    -   赋予不同的状态：Disabled 状态(不同类名)
    -   以及对 button 原生元素的一些原声属性是否支持？

#### 4.1.2 代码层面--组件成型选型（及用户可传入参数确定）

首层组件：Button
二层组件：无，默认props.children

    ```javascript
    <Button
        size="lg"
        type="primary"
        disabled
        href=""? // 支持原生属性
        className=""?
        autoFocus=""?
    >jinyan Button</Button> // 支持children属性
    ```

### 4.2 组件基础编码--《光身子》

    -   组件编写思路
    -   用到的工具

        -   classnames

                ```javascript

                npm install classnames --save
                and // 对应的声明文件类型也得安装一下
                npm install @types/classnames --save

                ```

    -   组件的不同可传入参数都是由类名确定的，先把实体光身子写出来，对应类名都能加对
    -   然后再逐个写类名对应的样式，这一节是添加 Button 基本样式

### 4.3 给组件穿衣服--《加样式》

(前面基础组件编码中都是自定义加好类名，这部分就是根据已加好的类名对应添充样式即可)

#### 4.3.1 分析按钮基本样式

    1. 大致看起来：文字颜色，文字居中，border，box-shadow，disabled 等属性
    2. 不同的 ButtonSize： 大小控制的属性其实是按钮的 padding 控制的还有 font-size 的不同还有 border 的不同。
    3. 不同的 Button Type：background 颜色不同，border-color 不同，字体颜色不同，hover 的状态不同颜色形状显示
    ==== 分析完后，第一步添加 button 的基础样式========
        - 一般都设在全局变量 sccs 文件中预设 buttong 相关的变量，可见该文件 buttong 部分方便维护
        ==== 第二步添加基础 size 属性 =============
        ==== 第三步添加 Button Type 加一系列的颜色 ====
        ==== 最后处理特例，给 linkButton 添加特例 ======
    4. 注意点：
        1. 样式里用的&.disabled,
        &[disabled] 会被编译成 .btn.disabled, .btn[disabled]这种意思就是当前类名并且有 .disabled 类名的元素，逗号后面是属性选择器带这个属性的,这 2 任意一种都会被选中或都被选中。
        1. 添加基础 size 样式因为会涉及不同大小的 css 属性要切换类名，每个类名都涉及到 padddingborderborderradios 这些东西可以用 scss 中的 mixin 解决 css 代码重用问题，所以 styles 新建了\_mixin.scss 模块文件----注册 mixin 时用@mixin 名字 {} 使用时用@include 名字 传参调用

### 4.4 最终打磨

    见buttong.tsx编写细节完毕

### 作业-完成 Alert 组件编写

见作业 pdf 题目要求

## 五、组件测试

### 5.1 为什么要测试

#### 5.1.1 写完组件没有测试的痛点

    -   测试组件好不好用的时候，唯一的方法就是手动创建一大堆不同类型的组件通过传不同类的属性控制生成然后用肉眼观测页面组件是否正常显示
    -   当我更新代码，给组建添加新功能的时候，还需要再把每个类型组件都实现一遍，看看新加的代码对原来的功能有没有影响，这样效率实在是太低了

#### 5.1.2 国内互联网测试现状

    -   重视程度严重不足
    -   没有时间啊
    -   不会写测试

#### 5.1.3 测试的重要性

    -   高质量的代码
    -   更早的发现 Bug，减少成本
    -   让重构和升级变的更加容易和可靠
    -   让开发流程更加敏捷

#### 5.1.4 测试金字塔

ui-service-unit：从上到下金字塔三角形的形状
unit test(单元测试)：指把代码分成单独的互相独立的部分，没有相互的依赖，测试每一个部分都可以良好的工作(这里可以联想到 react 的每个组件)
service test():将部分 unit test 组合起来，还可以测试它组合起来是否可以良好的工作
ui test(E2E 测试)：测试模拟真实用户场景，对整个应用进行测试，可以模拟真实用户的行为，比如点击填写表单的事件登陆登出等一系列的操作

    -   通过金字塔可以发现，unit test 是用的最多的，它非常容易编写，改动比较小，容易维护，跑起来用时比较多。金字塔越往上就越少，如 UI test 改动很大难以维护跑一次用时很长，所以我们应用应该有很多的单元测试一些 service 测试及搭配很少的 UItest。。
    -   现在很多公司的错误现状就违背了上面的金字塔即大部分都是靠 QA 的 manual 手动测试，然后 qa 写一大堆 uitest 测试，由于开发时没有介入 ui test，所以 ui 测试就经常
        会出错和修改，然后 servicetest 和 unittest 就异常的少，因为开发根本没时间去写

#### 5.1.5 react 组件特别适合单元测试

    -   components 组件化合适
    -   function 函数，有 hooks 后组件都可以是函数式组件，因为纯函数是最好写测试的(有固定的输入就有固定的输出)
    -   单向数据流的方式：单向数据流让组件会随便随着外部输入的数据和改动。我们只是要测试是否改动触发相应的回调即可

### 5.2 Jest 框架

> [参阅官方文档](http://jestjs.io)

想在我们的项目中添加测试，我们需要一个通用的测试框架，根据特定的语法来写测试用例，并且可以运行这些测试，如 moka，等框架，现在介绍这个 jest 框架后起之秀是 facebook 出品的一款，它吸收了几位前辈的特点并且有很多新的特性

    -   很通用，在 Babel，ts，node，react，angular，vue 中等等都能支持他很通用
    -   零配置
    -   只需要--coverage 代码就能实现出一份报告
    -   easy mocking
    -   great exceptions 简约的错误报告让我们知道代码哪写的有问题，这个用例为什么没过
    -   它还是 create-react-app 默认的测试框架

### 5.2.1 测试相关概念

**_断言_**：断言一个值是否对应相应的一个结果这就是精髓所在，判断输入经过计算得到的输出是否是预期的结果，断言由通用的框架提供一定的语法来完成这项工作
就是使用文档 api 的 using matchers 中的一些 toBe 语法
常用的 using matchers：

1. common matchers(通用的是 toBe()不用指定什么类型值，下面都是需要指定的 toBe 类型 toBeNum())
2. Truthiness(判断是不是 bool 值)
3. Numbers
4. Strings
5. Arrays and iterables
6. Exceptions
7. and more

### 5.2.2 根目录下建 jest.test.js 测试文件小试牛刀一下

每个用例都叫一个 case，每个 case 一般都会测一个独立的功能点，细节见该文件。
写完一个测试用例后，运行 `npx jest jest.test.js` 命令即可
`npx jest jest.test.js --watch`就启动监听服务了不用每次修改测试用例都执行命令

### 5.3 react 测试工具

前面 jest 是通用测试工具还不够，我们需要一个特殊测试工具可以把 react-component 渲染或说挂载到测试用例上去。facebook 专门推出了一套测试工具叫 Test Utilities，但是这工具方法复杂而且难记，用起来效果不是很好，所以其他开发者将这套工具做了层封装，
其中做的比较流行的工具有两种：

1. Airbnb 推出的 Enzyme: 通过它能够轻松对 react 组件的输出进行断言操控和遍历。它主打的特点就是类似于 jquery 中 dom 节点的链式调用操作语法，利用链式语法就可以实现 dom 节点的搜索调用和遍历取值
2. 一种是 react 官方推荐使用的 React Testing Library 库，它使得针对组件编写测试用例就像终端用户在使用它一样方便，在 create-react-app 脚手架 3.0 版本后已被默认添加了@testing-library

#### 5.3.1 讲解 create-react-app 自带的 testing-library

> [testing-library官方文档](https://testing-library.com/)
> 可参考 creaet-react-app 官方文档

      -   安装
          若是 3.3.0 版本后的会自动安装不需要安装依赖
          若之前的旧版本还是需要手动安装下依赖`npm install --save-dev @testing-library/react`

      -   安装完毕后就可以写我们的 test case 了，在我们项目中 jest 会自动把 _tests_/\*.js 和 \*.test.js 和 \*.spec.js 这三种看作测试用例文件
      -   接着在 Button 文件夹下创建 button.test.tsx 文件即可，细节见这个文件
      -   编写完后，运行 cli 自带的 npm run test 即可。PASS 掉就是通过了
      -   这只是最简单的测试用例，随着组件越来越复杂，测试用例也会变的复杂，对组件本身质量会很重要

    ```javascript
    react-testing-library测试用例的理念就是尽可能的贴近用户真实的使用流程
    //项目测试：npm run test(是跑所有的组件测试)
    //单个组件测试：npm test -- -t "单个的组件名或组件名的部分字就行"
    如npm test -- -t "auto"跑autoComplete组件
    ```

#### 5.3.2 正式添加 Button 组件代码测试用例

在开始写测试之前，我们要先安装一个非常趁手的小工具，让我们的测试更加方便一些，这个工具还是 testing-library 旗下的工具叫：**jest-dom** ：jestdom 相比 jest 测试工具针对添加了更多的 custom mathcers 断言方法(都是针对更快 dom 操作的一些断言，用这些断言更加清晰代码可读性更高维护变得更容易)如：toBeValid toHaveStyle 等

##### 5.3.2.1 安装 jest-dom

如果是新版本的 create-react-app 这个也是内置好的，旧版本的话
`npm install --save-dev @testing-library/jest-dom`
安装完毕后，我们需要以自定义扩展的形式给安装好的库给它装上去。
安装完后编写测试用例就可以使用更多的断言方法了。

      -   注意：create-react-app 支持一个 test-setup 文件，就是每当运行 jest 时候(即 npm run test 时候)就可以预先运行这个 setup 文件，就是每次测试之前全局通用的一个配置放在 setup 文件里是再好不过了，若新版本 cli 这个 setup 文件也是默认有的在 src/setupTests.ts 文件。
          旧版本的话还得在 src 位置下新建这个文件，内容都是一样的。

##### 5.3.2.2 开始编写 button 组件测试用例

写测试用例都需要用 describe 关键字分类下分类里面再写 test 函数或 it 函数作用都一样，详见该文件,,写完后运行 npm run test 都是 PASS 就过了

### 作业：给Alert组件添加测试用例

## 六、完成 Menu 组件编写

### 6.1 menu 组件需求分析

#### 6.1.1 原型图层面---- Menu 最基本样式

自己构建个原型图自己充当设计师考虑：一般分为顶部横向导航和纵向侧边导航两种导航，每种导航又分可点击或 hover 下拉菜单的和不可点击的两种类型，而且导航中每个按钮都可选支持 active 状态高亮 hover 效果和属性禁用效果，都是提供全局性的类目导航点击都能展开和关闭。

#### 6.1.2 代码层面----- 组件成型选型（及可传入参数确定）

看完原型图就得从代码层面考虑代码最终效果下。

首层组件：menu (一些用户级属性都得从首层组件坐context车透传下去)
二层：menuItem或SubMenu
三层：menuItem
四层：无组件，默认propschildren

    ```javascript
    // 开始选型，列出可选方案
    // 第一种：一个不太完美的解决方案
    const items = [{disabled: false,element: (<a>title</a>)},{disabled: true,element:'cool link'}]
    <Menu defaultIndex={0} items={items} onSelect={'选中回调'} mode="vertical"></Menu>
    // 第二种：更加语义化，更像HTML标签层级式解决方案
    <Menu defaultIndex={0} onSelect={} mode="vertical">
        <Menu.Item>
            title one
        </Menu.Item>
        <Menu.Item disabled>
            disabled link
        </Menu.Item>
        <Menu.SubMenu title={'test'}>
            <Menu.Item>
                下拉菜单项
            </Menu.Item>
        </Menu.SubMenu>
        <Menu.Item>
            <a href="http://www.google.com">goole</a>
        </Menu.Item>
    </Menu>
    // 所以选择第二种
    // 接下来属性分析即可传入参数确定
    interface MenuProps {
        defaultIndex: number;// 默认高亮
        activeIndex: number;// 哪个是高亮
        mode: string; // 某种常量
        onSelect: (selectIndex: number) => void;
        className: string;
    }
    interface MenuItemProps {
        index: number; // 序列哪一项
        disabled: boolean;
        className: string; // 可以自定义添类名
    }
    ```

### 6.2 基础组件编码--《光身子》

编写 menu.tsx,menuItem.tsx 文件
写好组件都在 app.tsx 导入使用测试下
6.3视频看完后基础组件功能编写完了，还需要对现有代码升级一下做二次开发，一些组件更深的优化思考需要增加，如只能让menu子组件是menuitem元素不能是其他元素，index属性手动挨个加太麻烦了--这就需要代码升级解决他们。
下节课先把基础功能组件的样式添加好，对应的基础小测试添加好，再去考虑基础组件的功能升级二次编码。

### 6.3 给组件穿衣服--《加样式》

(前面基础组件编码中都是自定义加好类名，这部分就是根据已加好的类名对应添充样式即可)
看原型图层面视觉分析效果来看，有横向和纵向两类，我们可以采用flex布局完成。

1. styles文件夹下中全局预设变量文件中增添menu和menu-item的预定义样式变量
2. Menu组件文件夹中新建_style.scss文件来编写组件样式。
3. 然后在indexscss文件中导入它

### 6.4 基础组件测试驱动--《代码升级的护航-用测试驱动》

因为是一个功能教多的组件在基础组件编写完后需要对基础组件功能升级进行二次代码组件编写，但是在原有基础上写新代码编写很有可能破坏原有代码的逻辑功能，为了不破坏，最好的办法是先给基础组件上添加单元测试。等我们在升级的时候通过测试的通过情况就知道我们有没有破坏原始的功能---这节课就为代码升级做保障(添加menu和menuItem组件的单元测试)
-- 测试来帮助检测代码质量
> 见menu.test.tsx文件

- 测试case都要分组每组里按这3方向写case:
  - 一般每组是从下面三个方向写case
  - 1：提供默认属性是否正常现实
  - 2：行为
  - 3：特例
- 写完测试后，以后编写组件代码升级就不需要在浏览器中查看功能了直接看测试通过即可

### 6.5 代码升级--《二次编码》

主要细节见menutsx与menuitemtsx文件
本次升级任务：

1. 支持判断子组件类型

   1. 目前还是直接children的，react说直接在children上map方法来检测子组件类型是非常危险的行为，children是个不透明的数据结构，不能保证是数组，它可以是任何的类型，若函数类型调用map就报错了，为了解决这个问题react推出了两个方法来循环children即：React.children.map和React.children.forEach

2. 自动添加index属性
   1. 利用react提供的cloneElement方法，在menutsx中循环children时不直接返回child，而是clone下并动态添加index等属性。使用时就不需要apptsx中传入index。
   2. 先把menuItem中index属性类型设成可选的不是必须的

3. 功能继续升级--menu中的下拉菜单(submenu)
    1. 由新的component组件形式来代表下拉菜单的内容
    2. 先把下拉菜单的样式写完在Menu/_style.scss里再写Submenu组件基础展示：
       1. 写下拉菜单样式技巧是先不管它展示和隐藏先把他们都展示出来就好写了，这一步写完纯展示即可
    3. 接着给展示出来的静态下拉菜单做交互逻辑编写
       1. 下拉逻辑：先给其设为dislaynone，然后在特定时间触发时使用useState控制开关来添加特定的class就可以了
       2. 改造成横向是hover就能下拉，纵向就点击才可下啦，借助首层组件menutsx中把mode通过context传给submenu来判断是否可以hover下拉
          1. 组件jsx事件分类传入技巧：借助{...hoverEvents}和变量 动态分类传入jsx事件
       3. 完成subMenu子组件中触发onSelect，并添加点击后的active状态。这时之前用的index已经被SubMenu占用了，我们需要丰富下数据结构：
          1. 把index原number数据类型换成字符串类型，可以给submenu子组件的index设成“2-1”带杠类型的就好了。
          2. 我们先从首层文件menutsx改index类型开始.把相关所有文件的index都改成stirng类型
       4. 再加个功能：在纵向模式中，子菜单应该有默认展开的功能，这很常用，我们可以通过配置menu首层组件的props属性控制让它默认展开。见menutsx文件的里新加的defaultOpenSubMenus数组值，让SubMenu根据这个数组值做判断是否默认展开(还用context传递)

### 6.6 组件收尾，最终测试添加

> 见menu.test.tsx文件

如测试文件中引入刚写好的组件subMenu.tsx,对该组件测试，能重新学到testing-library特别有意思的测试知识。

这节我们学到了testing-library里的:
    1. toBeVisible判断节点是否可见
    2. 动态给测试用例添加样式表
    3. 用提供的wait处理异步操作等
可以发现这个react-testing-library真的是贴近用户操作组件的一些过程.

### 作业：完成Tab组件

## 七、Icon组件及Transition组件编写

### 7.1 Icon组件

这节主要学的是怎样把一个成熟的组件搬来添加自己的功能，从而适应自己系统的改造

#### 7.1.1 Icon组件分析

- 图标Icon的解决方案
  - ***上古时期-用雪碧图***\(CSS sprite\)：有不能缩放，不能使用css控制等缺陷

  - ***近代 - Font Icon***：它的出现解决了上个时代雪碧图的缺陷，它用字体文件字符编码代表了图标，然后通过特定的class加给类名插入到浏览器中

  - ***现代和未来-SVG***  优势：

    - 完全可控：可以用任何的css属性来控制它，而font-icon本身是字符，仅能控制字符相关的属性
    - SVG即取即用，而FontIcon要下载全部字体文件
    - FontIcon还存在很多奇怪的Bug(如当文件加载失败时会遇到各种奇怪的bug，浏览器还可能把这些图标渲染成各种各样奇怪的字符)

所以得出最佳的解决方案是inlineSVG方案，项目中采用第三方svg库(font-awesome)

- 图标种类繁多，还需要设计方面的知识才行，完全没有必要自己完成，推荐免费资源库：**react-fontawesome资源库**就是底层基于svg实现的。可以轻松的实现按需引用，你使用哪个图标就引用哪个图标
- react-fontawesome官方库的使用：使用可参考文档

        ```javascript
        // 需使用前要安装下面3个npm包
        npm i --save @fortawesome/fontawesome-svg-core // svg核心库
        npm i --save @fortawesome/free-solid-svg-icons // 免费中的solid分类图标库，也可以选择安装别的分类收费的等库
        npm i --save @fortawesome/react-fontawesome // react组件

        /*
           使用时：有两种使用方式：
           1- Explicit Import变量的方式(即下面icon属性传值穿的是faCoffe方式）
           2- Build a Library字符串的方式(即icon属性传的是字符串的‘coffe’方式，因为上面每次都要引入就很浪费时间，所以它提供了自己写字符串的方式）
        */
       // 使用方式一：
        import ReactDOM from 'react-dom';
        // 这是容器
        import {FontAwesomeIcon} from '@fortawesome/react-fontawesome'
        // 这是具体想要的哪个图标
        import {faCoffee} from '@fortawesome/free-solid-svg-icons'
        const element = <FontAwesomeIcon icon={faCoffee} size="lg"/>

       // 使用方式二：
        import ReactDOM from 'react-dom';
        import {library} from '@fortawesome/fontawesome-svg-core';
        import {fab} from '@fortawesome/free-brands-svg-icons';
        // 下面这种是饮用两个图标，貌似和方式一差不多也得引用变量，他还能引入IconPack，所有图标都引入进来,fas就是IconPack的简称
        import {fas} from '@fortawesome/free-solid-svg-icons';
        //import {faCheckSquare, faCoffee} from '@fortawesome/free-solid-svg-icons';
        // 使用其add方法将这3个图标添加到library里
        //library.add(fab, faCheckSquare, faCoffee)
        // 一次添加所有图标，这样就可以在使用时任意使用字符串了，不用在对应引入添加了
        library.add(fas)
        // 添加完后就可以使用字符串的方式使用图标了
        <Icon icon="coffee" theme="danger" size="10x">

        ```

#### 7.1.2 基础组件编码

> 详见Icon文件夹组件文件
我们这里将对fontawesome资源库的icon组件进行二次封装，达到传我们组件库主题颜色能生成对应颜色的图标
完成了不同theme传入就会给svg icon图标添加不同class
> (需求驱动类名，类名驱动样式)技巧：组件编码中，不用管样式css怎么写，直接就随心所欲加对应需求的名字类名即可，样式填充以后再说

#### 7.1.3 样式添加

建立Icon/_style.scss文件，进行样式编写
这里用到了scss的遍历方法可以循环给相应类名加样式。

#### 7.1.4 submenu组件代码升级--《submenu组件图标和下拉菜单动画效果》

这节我们给SubMenu的下拉菜单和图标都加上动画效果见subMenutsx文件及Menu/style.scss文件.suubmenu-title部分。图标动画采用css+类名切换直接处理，下拉菜单采用react官方动画库处理。

- animation动画是web世界的一个重要话题没，这节课是怎样在react应用中完成动画几种方法：
  1. **直接使用css** transform来完成(直接使用css永远是最好的解决方案，不需要引入其他js库最后打包的文件会非常小，浏览器也会使用更少的资源) ---***首选简单可靠效率高***

  2. **react官方动画库**：当有些情况没办法用css完成时，如当displaynone转化displayblock过程中加transition过渡效果等其他任何动画效果就会完全失效是加不上的，因为display不是一个标准的能支持animated属性，把displaynone去掉直接用opacity:0渐变效果可以达到但不是真正的隐藏元素实质还在，这时可以采用一种displaynone和transition**错峰**的解决方案，思路见外层图片笔记--这就不是简单css能实现的了。很幸运早就有第三方资源库react-transition-group来支持了------针对于react动画实现的库！
     1. 它可以让你的react实现基本的cssanimation和transition，我们使用它要注意的有三点：
        1. 这个组件其实是让你的组件从无到有，从有到无，在这过程中会添加多个描述组件生命周期的class名称，这些名称都是由时间顺序所排列的
        2. 这个组件库里有三个可使用的组件Transition+CSSTransition+TransitionGroup，我们可以根据不同的场景选择对应的组件
        3. react-transition-group库并没有使那三种组件本身并没有实现动画效果，非常轻量级，只是使用不同的class来区分组件进入enter和离开exit dom中的阶段，我们可以自行添加样式来实现动画效果
     2. 该动画库运行机制图见外层图片笔记。

**细节**：Menu/style.scss文件中直接给submenu--title类名使用flex布局属性让其垂直居中
> 开始搭配使用，styles/_animation.scss文件新增相关内容，新增mixinscss东西

- 当使用动画库配合上submenu的下拉菜单ul后，整体流程是通过的是图片笔记里的2张运行机制图。但是由于自己写的submenu组件类名周期和动画库周期里属性有点冲突导致没有**错峰**就在exit阶段有一个bug，即enter阶段下拉动画正常，但是exit阶段动画效果失效。(这是因为在exit阶段的运行流程图可以看出displaynone和opacity:1没有错峰，同时使用了就失效了)，有种解决错峰的方案就是在exit流程图中把.zoom-in-top-exit类名中displaynone删掉，使transition opacity渐变能正常运行后，把displaynone挪到react-transition-group动画库exit阶段的最后一个周期.zoom-in-top-exit-done里去,这样就完美错峰了，能正常动画了，但是还是不是很好。
  - 最好的方式就是脱离.menu-opened这个类来控制打开和合并，我们应该是从react-transition-group包裹的子节点来做文章，如果我们能让里面包裹的节点一开始是不存在的，我们点击切换到true即CSSTransition组件的in属性为true时子节点才被动态添加进来，当点击到in为false时，我们把节点给他删除掉，这样就完全不需要displaynoneblock来控制了，复用性增强也就不需要class来控制了----即CSSTransition组件给我们提供了这样动态加载子节点的接口机制---提供了unmountOnExit属性参数bool值类型默认false不开启，让它包裹的组件就动态加载卸载。当in属性为true时会给动态加载进来in为false时会卸载掉。掉，用这个后就可以把我们样式中displaynoneblcok删掉即可。

#### 7.1.5 添加测试-组件收尾

无测试略过

### 7.2 自定义Transition组件

上面已经完美用过CSSTransition组件了，知道怎么用了，但是在我们项目中，需要简化这个三方组件的用法，尽能的为咱们项目服务，属性能简化就简化根据咱们项目特点都做成默认支持的属性，我们就需要根据业务需要二次封装组件改造三方组件了，下面是需求分析给出代码选型：

#### 7.2.1 组件改造需求分析

- 原型图层面分析
- 代码层面分析-组件选型可props确定

        ```javascript
        // 三方组件原来样子
        <CSSTransition
            in={open}
            timeout={300}
            classNames="my-node"
            appear
            unmountOnExit
        >{node}</CSSTransition>

        //希望改造进化简化成，就这么几个参数，其他都是默认的，自己预设好几种动画效果，提供animation属性直接使用即可
        <Transition
            in={open}
            timeout={300}
            // 字符串字面量
            animation="zoom-in-top"
        >{node}</Transition>

        ```

#### 7.2.2 先写样式：styles/_animation.scss /_mixin.scss

#### 7.2.3 基础组件编码

>新建Transition文件夹/开始编写组件transition.tsx文件

`先安装下动画库 npm i react-transition-group 类型声明：npm install @types/react-transition-group`

transitiontsx组件写完后导出，然后在subMenutsx导入使用下

- 后面又升级增加了wrapper属性得以更多的功能

### 作业：Alert组件完成带动画效果---见对应pdf课件

## 八、Storybook - 本地调试组件和生成文档页面的利器

### 8.1 什么是Storybook

随着组件的复杂有些新的需求慢慢的冒出来，有些老的架构或功能开始拖累整个开发的进度，这时候需要重新审视下你的代码是否需要更新。目前我们这个组件库的目的就是要产出各种组件，而我们在开发过程中展示和调试的功能使用的是create-react-app给我们提供的默认的入口文件即App.tsx组件，在这个组件中调试一般会添加各个组件来调试，这个cra脚手架的入口文件是针对于Web应用来设计的，它并不适合来开发来展示一系列的组件，不适合管理组件库，并且还缺乏行为追踪和属性调试功能(行为追踪即添加consolellog函数来测试点击行为，和添加不同的属性测试功能)

- 目前开发的痛点
  - create-react-app入口文件不适合管理组件库
  - 缺少行为追踪和属性调试功能

- 组件完美开发工具应用的特点
  - 分开展示各个组件不同属性下的状态
  - 能追踪组件的行为并且具有属性调试功能(比如事件用一个追踪器像单元测试一样，属性调试即一个input输入框输入不同属性页面会及时给他渲染出来)
  - 可以为组件自动生成文档和属性列表能供给用户用

> Storybook工具可以满足我们这些功能，具体介绍见官方文档

### 8.2 准备工作

- 安装：分为自动安装和手动安装

        ```javascript
        // 采用自动安装，sb就是storybook的简称
        npx -p @storybook/cli sb init
        // 安装完后会在当前你项目下新增下依赖+新增几个addons.js + configjs + stories/0-Welcome.stories.js等后缀.stories.js文件
        // 安装后，使用npm run storybook 来运行。
        // 运行后会有个storybook风格的应用web程序，会有生成的src/stories文件夹，文件夹下面是.stories.js后缀的各个sb展示组件。src/stories/0-Welcome.stories.js是web程序打开的欢迎页
        ```
- 自己编写后缀文件里面按照给出的后缀文件的模版写case就行，每种export出的都会展示到storybookweb页面中去

> 老师演示版本是5.2.8版本的，与新版本6.0.21版本有些许不同配置方式也不同。为了跟老师同步我们安装指定版本storybook。`npx -p @storybook/cli@5.2.8 sb init`
> 5.2.8版本有时候会有bug，只能在tsx文件末尾加个分号才行

- Storybook生成的book用的组件case默认是js类型的，怎样让storybook完美支持typescript的。
我们用Babel7支持ts3.5编译转化，参考官方文档可知，只需要按照官方文档在.storybookw文件夹下新建个webpack.config.js配置文件即可，把官方文件内容拷贝进来即可。配置完后就可以把storybook下的js文件都改成ts了。
  - 然后将.storybook/config.ts(js)配置文件(***这个配置文件是项目跑story之前经过的配置处理***)改后再把该文件里正则中的js改成tsx后缀，../src/stories改成../src即可，让src下所有组件都被处理。
  - 里面用到的presets就是babel转换过程中的一系列规则而已。
- 新版本安装后会自动根据当前项目支持ts，所以不用管,新版本配置文件是main.js,旧版本是configts

### 8.3 为我们Button组件添加story

先说下目录规则，为相关组件写stories文件，我们都写在components文件下各个组件目录中这样比较清晰愤分明。如见components/Button/button.stories.tsx文件。

- 写故事的写法有两种写法：Component Story Format(CSF也新的) 和 MDX(新推出的) 和 storiesOf API 三种。
  - 我们采用比较传统的storiesOf写法，为什么不用CSF形式呢？
    - 有一个弊端，它case直接就是抛出函数名作为故事名case名，就没法用中文了，对中文组件库不太友好，就用传统写法storiesOf API

- 当我们写好button组件的stories case后，发现没有Button组件样式storiestsx中没有引进来，我们去./storybook/config.ts配置文件中改一下加一行引入总入口scss文件即可，要是不支持scss文件编译再在webpack.config.js中配置下sassloader。
- 开始button组件编写多个story case即可。

### 8.4 Storybook addon-info插件

#### 8.4.1 插件介绍

storybook的一大亮点就是其插件系统，插件系统在任何项目中都代表了一种良好的架构思想，在storybook中插件称为addons
addons插件分为两大类：
    1. 第一种是Decorators(装饰器即接受一个funtion类型返回一个其他节点包裹着我们传进来的function调用主要节点，来修改装饰组件)见button.stories.tsx中CenterDecorator的写法。
    2. 另一种是Native Addons，它除了显示组件显示本身还能做更多事情，如它可以在组件故事之外的区域底部栏创建一个pannel然后和pannel产生交互如默认pannel是Actions项，官网有很多Native Addons可供你添加如Knobs(可以手动填入属性能自动改变组件外观)，还有source点击按钮会显示当前组件的源代码。。项目默认安装好的是addon-actions和addon-links这俩插件。
       1. 使用方式：安装好后，直接在addons.ts里导入其注册文件即可。
注意：当我们文件写jsx时会报错，把文件名后缀改成带x的tsx jsx就可以了

#### 8.4.2 添加addon-info插件

写的好的组件库一般都有非常详尽的文档说明和使用方式，说这个组件在什么情况下使用它的参数都有什么作用
一个好的文档至少应该包括：组件说明何时使用+代码演示实例+可以展示实例源代码(咋用的)+详尽的API参数的详细说明

所以可以使用我们storybook最流行的一个addon(插件)叫addon-info来解决上述问题。
`安装： npm i -D @storybook/addon-info    npm i --save @types/storybook__addon-info`
注意：这个addon-info没有types定义，我们要再单独安装一下

然后添加这个addon-info插件，上面两种方法添加，我们这去storiesOf级别添加，见button.stories.tsx文件。

#### 8.4.3 怎样修改一个addon的配置，我们可以从三个维度来展示一个完全不同的力度

- 最大的是可以全局配置addon的属性
- 其次是每个大的story级别去配置addon属性(每个组件文件是一个story，里的storiesOf函数处就是出口)
- 最小粒度是从配置整个case去配置(就是在每个case的add函数的第三个参数,这个优先级是最高的会覆盖上面配置)
我们展示后两种添加方法。见button.stories.tsx文件。这样就可以为我们的开发文档丰富我们的story信息，在展示组件的同时还能展示更丰富的内容，如可以拷贝源代码示例，说明文档，组件属性表格等等
这都是自己去写开发文档的，下节介绍代码注视使开发文档自动生成的方法。

### 8.5 自动生成文档---(react-docgen)

它是基于react提供的一个文档生成工具,他是一个命令行工具，使用ast-types和@babel/parser去分析react组件，并且可以把其中的信息抓取出来规定的特定的格式写的annotation(注释)内容，就可以自动生成开发文档

- 这节课完成自动生成文档任务要经过两个步骤：

    1. 第一是**_展示props_**：分析typescript中react组件作为function传入的参数，并且以表格的形式显示
    2. 第二步才是**_添加注释_**：添加annotation(注释)并且显示在表格和组件的主体介绍中

#### 8.5.1 完成第一个任务：展示props

所以这节先完成第一个步骤，大家都知道storybook是自带react-docgen插件的，由于我们代码是typescript，我们需要再装另外一个loader叫**react-docgen-typescript-loader**来良好的工作，这个loader主要目的就是生成proptypes的表格。
`安装：npm install --save-dev react-docgen-typescript-loader`

- 安装完了以后我们就可以改造下我们的webpack.config.js因为它是个loader，所以webapck配置中使用下这个loader。
- 然后当前5.2.8版本还需要在react组件中的Componennt等东西需要提前导出来再使用，不能直接用React.Component,还有React.FC等等类似的，这是当前版本的bug。见button.tsx文件。
- 在组件的导出方式也要改造下，export default 组件名字得配合export 组件名字才行见见button.tsx文件。@EXPORT处，然后运行npm run storybook即可
- 但此时会把一些类型别名的types没展开直接就显示的名字，还有继承的一些原声属性也默认全都显示了出来有好几百个，还需要webpackconfig 的react-docgen-typescript-loader使用中添加写options选项配置，配置完后就显示正常了。

#### 8.5.2 完成第二个任务：添加注释

> 利用storybook自带的JSDoc工具
添加注释是要符合一个叫JSDoc的一个标准的使用最多的一个注释格式。去官方文档搞清注释格式的标准后，我们就可以添加注视了。
JSDoc有两大类的诸事，一种：是从你函数主体里提取你写的注释信息并展示在组件旁边见@ANNOTATION2。
另外一种：是从props属性列表中提取你写的注释并展示在storybook的属性表格中见@ANNOTATION1。

- 注释中支持一些给出的格式标准编写，还支持md语法编写
- 写完注释后，必须得保持组件stories.tsx中add方法第一个参数的名字必须与组件文件button.tsx中注释的那个组件的名字保持一致才可以正常显示

见button.tsx文件。

### 8.6 Storybook最终样式美化

- 第一个任务是给所有stories包裹的组件添加简单的样式
  - 使用自定义的全局decorator来做，这样就能给所有组件都自动加上样式，见config.tsx文件

### 作业：给剩下的组件完成对应的stories故事编写

## 九、表单世界组件

### 9.1 Input组件

#### 9.1.1 Input组件需求分析

##### 9.1.1.1 原型图层面视觉分析

根据设计师给出的原型图来个视觉分析可知，input框有个基本样式，分别含size，disabled状态，input带图标(如一个日历图标)，input带前缀后缀等这几个维度的设计稿。

##### 9.1.1.2 代码层面-组件选型及props确定

    ```javascript
    <Input
        disabled
        size="lg|sm"
        icon="fontawesome 支持的图标"
        prepand="input 前缀，string 或者 ReactElement"
        append="input 后缀， string 或者ReactElement"
        {...restProps} 支持其他所有的HTMLInput原生属性
    />
    ```

#### 9.1.2 基础组件编码

> Tips: 一个组件是由4部分组成的：主体代码 + 样式文件 + stories文件 + test文件
(test文件一般是组件完成后写的，也有一种TDD写法即测试驱动组件先写测试，然后用代码将一个个测试face掉，我们开发过程中并没有采取这个模式，其他3个文件并没有特定的书写顺序可穿插进行)

新建Input文件夹，见从input.tsx开始。这节注重开发流程，牢记组件编写流程比代码重要

#### 9.1.3 添加样式

- 给新组件样式的第一步就应该是先去全局预设变量scss文件定义好全局变量，可利于全局配置性--见_variables.scss文件中的//input 处
- 然后在在组件文件夹中编写组件样式文件_style.scss.

#### 9.1.4 给组件写故事了--编写input.stories.tsx

### 9.2 AutoComplete组件

自动补全组件也就是联想组件，用在input输入框上输入搜索词自动联想出下拉框可能出现的自动补全的关键词，类似于github官网的那个搜索框。
基于原型图知，也是基于Input组件的支持的。
AutoComplete组件是在Input组件上做更多的事情，经过你输入的筛选以后，添加一个下拉菜单，现实一系列的筛选后的结果，点击下拉菜单选项后，值会自动填充到Input上面去，他的props属性应该怎样设计呢？

#### 9.2.1 组件需求分析

##### 9.2.1.1 原型图层面多维度分析

基于原型图知，也是基于Input组件的支持的。
AutoComplete组件是在Input组件上做更多的事情，经过你输入的筛选以后，添加一个下拉菜单，现实一系列的筛选后的结果，点击下拉菜单选项后，值会自动填充到Input上面去，他的props属性应该怎样设计呢？

##### 9.2.1.2 代码层面--组件选型及props确定

- 数据筛选逻辑：不应该放到组件里写死，因为筛选逻辑根据业务场景会千奇百怪，有的是同步筛选，过滤字段即可，有的是异步筛选，每次值都需要请求下接口获取展示项，有的还要对筛选的值进行非法字符转役和其他转化，--所以筛选逻辑应该抛出去，由用户去决定所以决定了组件props中增加一个fetchSuggestion函数来执行用户自定义的筛选逻辑。
- 当数据筛选处理后会拿到一组数据，展示在下拉菜单里，而且每项还有点击事件点击后会将当前项的值同步到Input组件上，因为点击option项的值需要交给用户自行处理，所以这个点击事件处理函数也要抛给用户，由用户自定义事件处理逻辑

        ```javascript
    const a = ['1', 'abc', '']
    interface AutoCompleteProps {
        fetchSuggestions: (keyword: string) => string[] | Promise<string[]>
        onSelect: (item: string) => void
    }
    const handleChange = (keyword: string) => {
        // 用户筛选逻辑函数有可能是同步有可能是异步。异步的就得等待接口所以此返回类型还有可能是Promise类型(Promise的返回值是string[])
        return a.filter(item => item.includes(keyword))
        return fetch(`url?keyword=${keyword}`)
    }
    const handleSelect = (item: string) => {
        console.log(item)
    }
    <AutoComplete
        fetchSuggestions={handleChange}
        onSelect={handleSelect}
    />
    // custom option自定义下拉选择项模版
    // keyboard support
    // 异步时不一定非要每次input框改变都去触发请求，可以考虑防抖的加入debounce
    // click outside to hide selectMenu
    // 这些都是后期优化的组件功能支持，前面只是基础功能props确定
        ```

#### 9.2.2 基础组件编码

> 新建AutoComplete文件夹，autoComplete.tsx组件文件开始编写
> 不要一开始就想着写多完美的解决方案，写代码呢一定要循序渐进

写完基础组件，再在.stories.tsx文件中写故事

#### 9.2.3 组件功能升级---自定义模版功能

即我们目前展示的都是li标签，我们可以传入一个functin根据用户需求让他自定义展示特定的内容，这时需要增加个props属性叫做：***renderOption***

目前props的data接口只是简单string[\]简单类型，真实项目中需要复杂的接口类型展示丰富的信息，需要是Object[]结构,也类似于Table组件的data数据结构，所以autoComplete.tsx文件新增DataSourceObject接口抛出

#### 9.2.4 组件功能升级---支持异步请求

目前的fetchSuggestions返回的是一个同步筛选后的数组，要异步的话最常见的解决方案就是让他返回一个Promise实例，我们这节就对fetchSuggestions做下修改。

- 异步请求调好之后，再使用我们已做好的Icon加个loading图标，要不会白等时间
- 这时候还没有加防抖和节流，所以键盘每次按下去都会发起请求，这当前一个发起请求并没有管上一个请求有没有完成，这就会严重影响性能和资源浪费

#### 9.2.5 组件功能升级---使用自定义Hook实现函数防抖

比如我们快速打出一个单词四个字母，本来只查这个单词就行了，但是它发起了4次请求，每次按键都发起了，然后每个异步请求返回的时间顺序不一定结果也有可能错误；

***理想做法***：当用户输入后一段时间内，如果还有字符输入的话就暂时不去发送请求，过了一段时间了再去发送---解决它就叫函数防抖(debounce)。

在lodash中就有写好的解决方案写的一个debounce函数：

***原理非常简单：*** 它通过闭包保存一个标记，保存这个setTimeout返回的一个值，每当用户输入的时候就把前一个setTimeout给clear掉，生成一个新的setTimeout，这样就能保证输入的字符后的时间间隔内如果还有字符输入的话，就不会执行回调函数。
    我们并没有用原生js方式实现防抖函数，而是使用react自定义Hook话，会更简单简便易懂地完成这个任务。原生方式会写的多一点

---

我们组件内的发起异步请求很明显是函数的副作用，它就应该写在useEffect里，见autoComplete文件中添加useEffect

- src下需要新建hooks文件夹，来装我们的自定义hook文件，新建hooks/useDebounce.tsx文件作为自定义代码逻辑复用的防抖hook。然后在autoComplete中使用它

#### 9.2.6 组件功能升级---支持键盘事件

键盘事件能很方便的在搜索结果中上下移动，通过键盘快速完成操作，我们可以在input框中添加键盘事件onKeyDown---上下箭头选型高亮+回车填充值+ESC关闭搜索结果；见组件文件编写。
***上下箭头选型高亮***：我们创建一个state来指示当前高亮的是哪一个条目，然后可以根据这个变量给条目添加预设className类名，从而实现css样式,切换高亮效果主要就是进行类名的切换

#### 9.2.7 组件功能升级---利用useRef实现clickOutSide功能

**功能背景**：当我们在下拉菜单里面按enter键或点击某一项后会额外触发一次另外的搜索，这是不想要的----解决方式我们需要一个状态变量来加以限制，通过这个状态变量在useEffect副作用发请求前通过状态变量做限制，判断这次要不要做限制。
**什么变量？**：大家第一感觉是创建一个usestate变量，我们需要的和这个变量不需要引起页面重新渲染
，仅用来保持一个不同的状态即可。我们可以用**useRef**它可以用来保存任何值，可以在多次渲染中都可以保存相同引用，完全可以看作一个普通的js对象(`但也有区别： useRef() 和自建一个 {current: ...} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。`)即triggerSearch这个useRef值。

##### 9.2.7.1 完成clickOutSide的useHook功能

- 使用useRef的另一个特性完成ClickOutSide功能，点击下拉菜单外边触发菜单隐藏，这个是一个比较常用的功能，我们可以把他做成一个自定义hook，完成状态逻辑复用
- 解决思路：
  我们想要辨人下拉菜单上所有的点击事件，我们就需要绑定一个够大的点击事件，比如说给document上绑定一个点击事件，然后我们看点到的是什么元素，再看目标区域中是否包含这个节点，如果包含就说明点的是区域组件内的元素就什么都不用做，若不包含，则处理相应逻辑，下拉列表隐藏之类的。
  详见autoCompletetsx文件中对应的useRef=>componentRef值相关处理，和新建自定义hook文件src/hooks/useClickOutside.tsx
这是一个通用的功能，所以写成自定义hook复用逻辑比较好。

#### 9.2.8 AutoComplete添加单元测试

react-testing-library测试用例的理念就是尽可能的贴近用户真实的使用流程
项目测试：npm run test(是跑所有的组件测试)
单个组件测试：npm test -- -t "单个的组件名或组件名的部分字就行"
如npm test -- -t "auto"跑autoComplete组件

好的组件是一定要有测试的

#### 9章作业：Select组件--作业见对应章节pdf



## 十、完成难度Upload组件

### 10.1 Upload组件需求分析

这个上传组件可以说是组件库中比较复杂的组件，还需要和异步打交道，复杂组件只不过是逻辑上需求上更丰富而已，
开发复杂组件最重要的思想：就是从最简单的case入手，在实现最基本功能的情况下再慢慢进行功能升级
一开始一定要避免过度设计。
#### 10.1.1 原型图层面分析
见图片笔记![Upload基础原型图.png](../../ts+react-仿Antd/四、组件库起航/图片笔记/Upload基础原型图.png "my-logo")
上传的部分是一个非常需要考究的内容，像组件一样有一个完整的生命周期。见图片笔记的[Upload生命周期图上.png](../../ts+react-仿Antd/四、组件库起航/图片笔记/Upload生命周期图.png "cuole")
[Upload生命周期图下.png](../../ts+react-仿Antd/四、组件库起航/图片笔记/Upload生命周期图下.png "cuole")
可知onChange，onRemove，beforeUpload都是该组件的生命周期部分会在特定的时间触发它们。

- 我们可以在beforeUpload的生命周期中做些预上传的检查工作，检查文件大小格式等问题，在onSuccess钩子中可以用来提示成功信息等等

#### 10.1.2 代码层面分析--组件选型及props确定

> 尽可能多的把处理逻辑的接口都抛给用户，让用户来传回调逻辑
    ```javascript
// 最简易的版本 组件选型
<Upload
    action="https://upload!"
    beforeUpload={()=>{}}
    onProgress={()=>{}}
    onChange={()=>{}}
    onSuccess={()=>{}}
    onError={()=>{}}
    onRemoved={()=>{}}
>
    <Button>click to upload</Button>
</Upload>
    ```

### 10.2 下一代Http库--axios

HTTP库里异步请求的主角-Axios，前端异步请求的一个历史发展
***几年前：***  原生XHR和$.ajax
    XHR是浏览器发送异步请求的一个对象，他的实例代码不是很友好,不太符合关注分离的原则，有点混乱，api设计不是很简介，有点繁琐，后来jquery给它封装了下简洁明了的写法$.ajax({type:'',url:'',data:{},dataType:'json',success(){},error(){}})，但是现在随着各种框架的发展，基于dom操作Jquery已经临危
    ---所以W3C组织又提出了新的API叫做fetch---
***Fetch：*** 这个api是基于promise的

    ```javascript
fetch('http://test.me').then(function(response) {
    return response.json()
}).then(function(data) {
    console.log(data)
}).catch(function(e){console.log('oops,error')})
    ```
刚出来时挺火的，但fetch是个底层的api，使用起来有点难受，还需要封装
    **缺点：**
  1.  只对网络请求报错，对400，500都当作成功的请求，我们得额外去处理它
  2.  默认不会带cookie(要带的话得手动添加配置项)
  3.  不支持abort，不支持超时控制(假如一个请求有非常长的时间我们无法abort掉即阻止请求在后台运行会造成流量浪费)
  4.  没有办法原生监测请求的进度

***AXIOS库推出：***
    1. 在浏览器端和node端都可以使用，浏览器端是XMLHttpRequests，node中用的是http模块
    2. 完全支持标准的Promise API
    3. 可以拦截请求和返回
    4. 可以转换请求和响应数据格式
    5. 可以取消请求，自动转化JSON数据
    6. 包里自带typescript定义

### 10.3 在线mock server 和axios使用

首先要发送一个异步请求就需要一个后端环境是一个restfulapi，我们第一个选择是在本地搭建一个mockserver本地运行，但是由于组件库主要是前端代码，最终的产品是纯正的适用于web界面的组件，所以在本地部署一个mockserver会显得多此一举----在这推荐两款线上mockserver服务：JSONPlaceholder和Mocky.io,我们项目用JSONPlaceholder，这节课的演练见App.tsx文件。
`npm i axios --save`

### 10.4 上传文件的基本方式

使用input typefile拿到文件后可以使用两种方式实现文件上传：第一种就是传统的submit表单提交的方式；第二种是使用js发送异步请求的方式(极力推荐的方式)

    ```javascript
// 传统表单方式
// <form method="post" encType="multipart/form-data" action="http://">
//     <input type="file" name="myFile"/>
//     <button type="submit">Submit</button>
// </form>
// 当我点击这个提交按钮时，它会运行这个form的默认行为，自动收集formchildren里表单数据然后直接发送一个http request到action对应的url上

// 这个文件上传发送的是文件的信息和普通的字符串不同，它属于一个二进制格式，所以这个encType设置成了multipart/form-data。
    ```

**注意**：上传文件或表单发送时里面有二进制文件信息的话，最好设置成multipart/form-data格式，除了这种格式还有其他两种格式：

1. application/x-www-urlencoded(the default)：这是一些表单数据，它们被encoded到了body或url中去传送了
   - 如果要发送大量二进制数据，使用这种格式显然是低效的
2. multipart/form-data：是专门发送二进制文件所设计的
3. text/plain格式。

#### 10.4.1 异步请求文件发送

见App.tsx文件,要做到input type file控件change事件发生以后让它自动发送请求。

### 10.5 基础组件编码

#### 10.5.1 基本流程

> 见Upload文件夹/upload.tsx文件
这节课把上传文件异步请求基本流程在Upload组件中实现
这节课我们要实现它设计图里的最主要三个周期钩子onProgress+onSuccess+onError这三个。
**onProgress + onSuccess + onError**

- 这是复杂组件一定要循序渐进，先写好带基础功能的upload组件即可然后再慢慢升级，刚开始写jsx时也不用想如何高度抽象，先写死jsx模版标签即可。后续再按需抽象。
- 完成3个生命周期并且保证每个钩子都得有向用户抛出(自定义逻辑回调)的接口以便服务用户

#### 10.5.2 完善生命周期

这节课让我们把其他(非最主要)生命周期钩子给补充完整
**beforeUpload + onChange(file)**

onChange(file)：在文件状态改变的时候被暴露出来,在成功和失败时都触发下onChange就行

#### 10.5.3 创建列表数据-UploadList组件

从原型图可知，上传成功以后要展示出上传后的数据列表，上传成功的文件失败的文件都会展现在列表里，也有可能是正在上传的文件，所以我们需要一个数组对象的形式来描述各种文件的状态(一系列的文件状态)。----见uploadtsx文件中先定义好这个数据结构再以它展开写。

- 然后再定义fileList of state数据，在上传开始的时候第一次更新这个数据
- 接下来就是在上传的过程中更改它的值(至少是更新他的percent值)
  - 在更新的过程中有点犯难，setState函数是异步的，想要拿到上次的值，可以使用setState(()=>{})的写法。创建updateFileList方法。在多处适当的位置更新fileList

#### 10.5.4 显示上传数据-UploadList组件

> 可参考upload列表数据设计图

这节课负责把上节课拿到的数据用美观的界面把它展示出来，根据设计图可知，不同状态的数据展示出来样式都不一样，每条数据右边都是根据不同状态有不同图标，uploading状态的还要额外添加一个带百分比的进度条。当我们hover每一条时，会出现删除红x的图标，点了x以后会删除这个条目，并且触发用户自定义的onRemove事件---其实就是根据拿到的一组不同的值，展现不同的条数据

这节课进度条先不做，先列表统一样式写出来，需要新建组件来专门展示列表数据，在新建组件之前，需要先给uploadtsx新添2个props属性：
第一个叫defaultFileList(允许用户初始化的时候自定义传入一个列表可以直接显示为已经上传的文件信息，这个对我们测试文件列表也很方便不用上传以后才能看到而是传入什么就立即看到什么默认列表数据结果)
第二个叫onRemove(当从列表中删除文件的时候可以被触发)

#### 10.5.5 显示上传进度-Progress组件

这节课让我们完成进度条的功能也是单独写的一个组件叫Progress组件，它是一个纯展示的组件，根据传入的百分比来显示进度条，这个和上节课的uploadList组件一样，这种组件是主要是考察你html结构，怎样更好的实现与优化--这个不仅能给upload组件使用，还能给更多组件复用，它是一个通用组件，在各种场景中都可以使用

##### 10.5.5.1 专门给Progress组件做组件需求分析

>见Progress/progress.tsx文件
根据图片笔记进度条的设计图可知：

- 整体分为3部分：最外层是个灰色的长条可取名progress-bar-outer：
  - 分析可配置的点：条的整体高度可以配置，灰色的最外层要设为relative
- 中间的是绿色的爬进度条取名为progress-bar-inner：
  - 可配置点：他的颜色可以配置，应该符合我们系统的theme，把他设为absolute
  - 得让里面的数据垂直居中
- 最后一部分是里面显示的百分比数据：可配置文字是否显示

##### 10.5.5.2 组件编写
把progress组件编写完，
写样式时：先在预设全局变量上添加progress bars的预设全局变量，写了_style.scss样式文件

### 10.6 组件功能再升级
> 我们始终牢记我们的开发理念是循序渐进：先从简单流程基本流程入手，然后在基本的流程中再精益求精地发现更多的需求场景，可以把基本的流程看作一颗种子，种下去之后慢慢的剪纸修剪浇水最后长成参天大树

Upload组件从以下方面进行功能再升级：

1- 丰富化上传数据：

- 在上传数据时添加自定义Header
- 添加name属性-代表发到后台的文件参数名称(这类名字name给后台一般是写死的，目前那个file.name是活动的)
- 添加data属性-上传所需的额外参数对象形式的。
- 添加input本身的file约束属性-multiple(支持文件的多选)，accept(支持选择什么样的文件)等
- 上传请求时是否自动携带cookie，默认不携带，我们可以给出一个bool值

2- 展示更丰富化的界面和交互

- 自定义触发的元素(目前是写死的button)
- 支持拖动上传文件，松开鼠标文件就可以完成上传
- 点击上传文件名称 添加onPreivew事件

#### 10.6.1 丰富化上传数据

从两方面入手：

- 自定义HTTP post请求
  - 添加自定义header
  - 添加自定义name
  - 添加自定义post formData
  - 添加发送时是否携带cookie - withCredentials
- 自定义input属性
  - 添加multiple属性
  - 添加accept属性

开始编写从upload.tsx组件开始

#### 10.6.2 丰富化界面交互--拖拽上传drag和drop

自定义触发的元素已改好见upload.tsx组件文件

根据图片笔记，拖拽设计图分析可知：完成拖动上传应该是由一个状态属性控制，取名为drag属性见upload.tsx加上它。触发点击的时候或拖拽目标区域应该支持一系列的drag事件来支持drag和drop---这种事件有三种：DragOver事件(有文件拖到这个区域就触发的事件=>触发以后就添加特定class名：is-dragover) + DragLeave事件(当拖到这个区域又拖走了--这时候删除特定class名is-dragover即可) + onDrop事件(即拖到这个区域时松开了鼠标把文件放到了这个区域就触发了事件-通过该事件的事件对象拿到文件信息调给Upload组件即可)。

我们新建个子组件dragger.tsx完成这个交互，这个组件是一个外层的wrapper，把想要的组件包裹在其中即可

### 10.7 给Upload添加测试

写测试也是应该循序渐进，先写基本的测试测，再逐渐复杂的功能也测了

#### 10.7.1 异步怎样测试

这节课测试有学新东西：学习怎样在测试中mock一个库的实现？

- 查阅jest官方文档可知introduction/Mock Functions这一块内容，就讲解了如何测试异步请求如何测试文件中mock一个库---使用jest.mock(..)方法如先用jest来接管axios，然后用jest提供的方式实现post方法，详见upoadtesttsx。

在测试用例中不可能真的去完成网络请求的发送也就是说我们需要改变axios的post方法的实现细节，见uploadtest文件

#### 10.7.2 拖动事件怎样测试

这节课接着上节课写，目前已经测到文件上传成功后，该测点击图标删除文件好不好用
***注意***：这个删除图标只有在hover上去才会出现，但是在测试用例中由于没有加载样式文件，我们可以直接完成对应操作

本节主要难点：完成拖拽的测试
**tips:** testing-library中的fireEvent有两种使用方式一种是fireEvent.click(节点)或fireEvent(节点，EventObject)

